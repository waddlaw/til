# Logic & SMT
リファインメント型を手短に説明するとこんな感じです。

> リファインメント型 = 型 + 論理的述語

このチュートリアルの残りで "論理的述語" について素早く確認することから始めましょう[1]。チュートリアルの構成としては、*構文*の説明から始め、述語がどのように*見える*か、それと*意味論*を説明という流れになっています。述語という素晴らしい言葉にどんな*意味*が含まれているか理解できるでしょう。

[1]:この章の内容を理解していれば、すなわち SMT の "S", "M", "T" が何を意味しているかわかっている。または QF-UFLIA (つまり、quantifier free theory of linear arithmetic と uninterpreted functions) が何を意味するか理解しているというという場合は、この章を飛ばして次の章を読みましょう。

## Syntax
*論理的述語*という言葉では非形式的になってしまうため、Haskell の*制限した*サブセットで Boolean valued term を記述します。特に、この式は*定数*、*式*、*述語*で構成される以下の文法に沿っています。

**定数** `c` は数字のどれか1つです。

    c := 0, 1, 2, ...
    
[2]:コードの := は ".. は .. と定義される" と読むと良いです。
    
**変数** `v` は `x`, `y`, `z` などのどれか１つで、これらはプログラムコードで束縛 (の値) を参照する。

    v := x, y, z, ...

**式** `e` は以下の形式のどれか1つです。式は変数の線形算術式と定数と未解釈関数適用 (uninterpreted function applications) をとして構成されます。

     e := v                   -- variable
       | c                   -- constant
       | e + e               -- addition
       | e - e               -- subtraction
       | c * e               -- linear multiply
       | v e1 e2 ... en      -- uninterpreted function application
       
**式の例** を以下に示します。

- `x + y - z`
- `2 * x`
- `1 + size x`

**関係** は通常の (算術) 演算子のどれか1つです。

    r := ==               -- equality
       | /=               -- disequality
       | >=               -- greater than or equal
       | <=               -- less than or equal
       | >                -- greater than
       | <                -- less than

**述語** は２つの式を比較して得られる原子述語、引数のリストへの述語関数の適用、演算子 `&&` (かつ), `||` (または), `==>` (ならば[3]), `<=>` (iff[4]), `not` を使った関係述語の Bool コンビネーションのどれか。

    p := true
       | false
       | e r e           -- atomic binary relation
       | v e1 e2 ... en  -- predicate application
       | p  && p         -- and
       | p  || p         -- or
       | p ==> p         -- implies
       | p <=> p         -- if and only if
       | not p           -- negation

[3]: `p ==> q` は "`p` ならば `q`" と読む

[4]: `p <=> q` は "`p` ならば `q` **かつ** `q` ならば `p`" と読む

**述語の例** を以下に示します。

- `x + y <= 3`
- `null x`
- `x < 10 ==> y < 10 ==> x + y < 20`
- `0 < x + y <=> 0 < y + x`

## Semantics
述語の構文はどう*見える*か、つまり、正しい述語をとして何が*記述*できるかわかりました。次は、述語にどんな*意味*があるかについて確認しましょう。直感的に述語は `&&`, `||`, `not` という Bool 値を扱う Haskell 関数のような演算子と `==>`, `<=>` の特別な演算子という感じがします。

**含意** 演算子 `==>` は次に示す Haskell 関数と同じです。(ここでは型シグネチャについては触れません。この関数は入力 `p` と `q` が*論理的*含意であるかどうかの等価性を `Bool` で出力するという意味です。)

```haskell
{-@ (==>) :: p:Bool -> q:Bool -> {v:Bool | v <=> (p ==> q)} @-}
False ==> False = True
False ==> True  = True
True  ==> True  = True
True  ==> False = False
```

**If-and-only-if** 演算子 `<=>` は以下の Haskell 関数と同等です[5]。

```haskell
{-@ (<=>) :: p:Bool -> q:Bool -> {v:Bool | v <=> (p <=> q)} @-}
False <=> False = True
False <=> True  = False
True  <=> True  = True
True  <=> False = False
```

[5]:鋭い読者は、引数の型が Bool のとき、 <=> は == と同一だと気づくでしょう。

**環境** は変数から Haskell の型へのマッピングです。例えば、以下のように定義される環境 `G` は

    x :: Int
    y :: Int
    z :: Int

`x`, `y`, `z` それぞれが `Int` 型にマップされます。

**アサインメント** は環境下において、変数から環境で指定された型の値へのマッピングです。例えば、

    x := 1
    y := 2
    z := 3
    
は `x`, `y`, `z` をそれぞれ `Int` の値 `1`, `2`, `3` にマップするという `G` 環境下のアサインメントです。

**述語を評価** すると、与えられたアサインメントにおいて `True` か `False` のどちらかになります。例えば述語


    x + y > 10

は、上記のアサインメントで評価すれば `False` となりますが、以下のアサインメントであれば `True` となります。

    x := 10
    y := 10
    z := 20
    
**述語が充足可能** もし、(環境内に) アサインメントが*存在*すれば環境内で述語は充足可能です。充足可能とは、述語を評価して `True` になることを言います。例えば `G` において次の述語

    x + y == z

は先ほどのアサインメントによって評価を行うと `True` になるため、充足可能です

**述語が妥当** 環境において全てのアサインメントで述語が `True` となるとき、述語が妥当と言います。

例えば、次の述語

    x < 10 || x == 10 || x > 10

は環境 `G` において `x` にどんな値が代入されたとしても、評価すれば常に `True` となるため妥当です。

