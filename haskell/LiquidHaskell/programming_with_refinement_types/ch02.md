# Logic & SMT
リファインメント型を手短に説明するとこんな感じです。

> リファインメント型 = 型 + 論理的述語

このチュートリアルの残りで "論理的述語" について素早く確認することから始めましょう[1]。チュートリアルの構成としては、*構文*の説明から始め、述語がどのように*見える*か、それと*意味論*を説明という流れになっています。述語という素晴らしい言葉にどんな*意味*が含まれているか理解できるでしょう。

[1]:この章の内容を理解していれば、すなわち SMT の "S", "M", "T" が何を意味しているかわかっている。または QF-UFLIA (つまり、quantifier free theory of linear arithmetic と uninterpreted functions) が何を意味するか理解しているというという場合は、この章を飛ばして次の章を読みましょう。

## Syntax
*論理的述語*という言葉では非形式的になってしまうため、Haskell の*制限した*サブセットで Boolean valued term を記述します。特に、この式は*定数*、*式*、*述語*で構成される以下の文法に沿っています。

**定数** `c` は数字のどれか1つです。

    c := 0, 1, 2, ...
    
[2]:コードの := は ".. は .. と定義される" と読むと良いです。
    
**変数** `v` は `x`, `y`, `z` などのどれか１つで、これらはプログラムコードで束縛 (の値) を参照する。

    v := x, y, z, ...

**式** `e` は以下の形式のどれか1つです。式は変数の線形算術式と定数と未解釈関数適用 (uninterpreted function applications) をとして構成されます。

     e := v                   -- variable
       | c                   -- constant
       | e + e               -- addition
       | e - e               -- subtraction
       | c * e               -- linear multiply
       | v e1 e2 ... en      -- uninterpreted function application
       
**式の例** を以下に示します。

- `x + y - z`
- `2 * x`
- `1 + size x`

**関係** は通常の (算術) 演算子のどれか1つです。

    r := ==               -- equality
       | /=               -- disequality
       | >=               -- greater than or equal
       | <=               -- less than or equal
       | >                -- greater than
       | <                -- less than

**述語** は２つの式を比較して得られる原子述語、引数のリストへの述語関数の適用、演算子 `&&` (かつ), `||` (または), `==>` (ならば[3]), `<=>` (iff[4]), `not` を使った関係述語の Bool コンビネーションのどれか。

    p := true
       | false
       | e r e           -- atomic binary relation
       | v e1 e2 ... en  -- predicate application
       | p  && p         -- and
       | p  || p         -- or
       | p ==> p         -- implies
       | p <=> p         -- if and only if
       | not p           -- negation

[3]: `p ==> q` は "`p` ならば `q`" と読む

[4]: `p <=> q` は "`p` ならば `q` **かつ** `q` ならば `p`" と読む

**述語の例** を以下に示します。

- `x + y <= 3`
- `null x`
- `x < 10 ==> y < 10 ==> x + y < 20`
- `0 < x + y <=> 0 < y + x`

## Semantics
述語の構文はどう*見える*か、つまり、正しい述語をとして何が*記述*できるかわかりました。次は、述語にどんな*意味*があるかについて確認しましょう。直感的に述語は `&&`, `||`, `not` という Bool 値を扱う Haskell 関数のような演算子と `==>`, `<=>` の特別な演算子という感じがします。

**含意** 演算子 `==>` は次に示す Haskell 関数と同じです。(ここでは型シグネチャについては触れません。この関数は入力 `p` と `q` が*論理的*含意であるかどうかの等価性を `Bool` で出力するという意味です。)

```haskell
{-@ (==>) :: p:Bool -> q:Bool -> {v:Bool | v <=> (p ==> q)} @-}
False ==> False = True
False ==> True  = True
True  ==> True  = True
True  ==> False = False
```

**If-and-only-if** 演算子 `<=>` は以下の Haskell 関数と同等です[5]。

```haskell
{-@ (<=>) :: p:Bool -> q:Bool -> {v:Bool | v <=> (p <=> q)} @-}
False <=> False = True
False <=> True  = False
True  <=> True  = True
True  <=> False = False
```

[5]:鋭い読者は、引数の型が Bool のとき、 <=> は == と同一だと気づくでしょう。

**環境** は変数から Haskell の型へのマッピングです。例えば、以下のように定義される環境 `G` は

    x :: Int
    y :: Int
    z :: Int

`x`, `y`, `z` それぞれが `Int` 型にマップされます。

**アサインメント** は環境下において、変数から環境で指定された型の値へのマッピングです。例えば、

    x := 1
    y := 2
    z := 3
    
は `x`, `y`, `z` をそれぞれ `Int` の値 `1`, `2`, `3` にマップするという `G` 環境下のアサインメントです。

**述語を評価** すると、与えられたアサインメントにおいて `True` か `False` のどちらかになります。例えば述語


    x + y > 10

は、上記のアサインメントで評価すれば `False` となりますが、以下のアサインメントであれば `True` となります。

    x := 10
    y := 10
    z := 20
    
**述語が充足可能** もし、(環境内に) アサインメントが*存在*すれば環境内で述語は充足可能です。充足可能とは、述語を評価して `True` になることを言います。例えば `G` において次の述語

    x + y == z

は先ほどのアサインメントによって評価を行うと `True` になるため、充足可能です

**述語が妥当** 環境において全てのアサインメントで述語が `True` となるとき、述語が妥当と言います。

例えば、次の述語

    x < 10 || x == 10 || x > 10

は環境 `G` において `x` にどんな値が代入されたとしても、評価すれば常に `True` となるため妥当です。

## 検証条件
LiquidHaskell はプログラムを実際に*実行する*ことなく動作します。その代わり、おおよそ次の2ステップによってプログラムが与えられた仕様を満たすかどうかチェックします。

1. 最初に LH は型とコードの組み合わせを*検証条件* (VC) の集合に落とします。VC はプログラムが与えられた性質を満たす場合にのみ妥当となる述語です。[6]
2. 次に、LH は VC が妥当かどうか決定するため[SMT ソルバ](https://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories)に問い合わせます。その結果は、プログラムが*安全*と判断されるか、*リジェクト*されるかのどちらかです。

[6]:この処理は[この論文](http://goto.ucsd.edu/~rjhala/liquid/liquid_types.pdf)に全て記述しています。

**STMソルバ** は全てのアサインメントを評価・列挙せずに述語 (VC) が妥当かどうか決定します。実のところ、述語が整数やリストなどを参照すると、無限に多くのアサインメントが存在するため、これは不可能です。そのため、SMTソルバは述語が妥当かどうかを推論するために様々な高度な*記号アルゴリズム*を使います。この処理は決定手続きと数学的論理の
成果によるものです。[Greg Nelson の博士学位論文](https://www.microsoft.com/en-us/research/people/qadeer/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fqadeer%2Fcse599f%2Fpapers%2Fnelsonthesis.pdf)はそれらの素晴らしいアルゴリズムを学習ために最適です。

**論理を制限する** 全ての VC クエリが*決定可能断片*となることを保証するために論理を制限します。これは LiquidHaskell をかなり自動化します。これは、型を使って性質の仕様を与えるため、証明の具体的な指示を行う必要が*なくなる*ということです。もちろん Haskell のコードで実装することもできます！この自動化は、全てのリファインメントがこれまでに説明してきた論理に属さなければ*ならない*という負担もありますが、ほんの少しの想像力があればこの論理でかなりのことができるはずです。[7]

[7]:特に、未解釈関数を使うことで多くの高度な抽象を生成することができます。

## Examples: Propositions
