演習 9.2 の考察その1
`hd` と `tl` を使わないと `Refinement type` がわからなくなるんじゃないか？と思っていたが、過去に出てきた `measure` の仕組みを見るとコンストラクタに対して自動的に `Refinement type` が挿入されることがわかる。

そのため、要素を追加するためにコンス演算子を使うとすれば、以下の `Refinement type` が推論されると思われる。。

```
data [a] where
  [] :: { v:Nat | size v = 0 }
  (:) :: a -> xs:[a] -> { v:[a] | size v = 1 + size xs }
```

ただ、分解の場合にリストの長さ `N + 1` が、リストの分解によって `N` になると推論できるのか？という疑問があった。

そのため、実際に `remove` を `hd`, `tl` 無しで実装して動作を確認したところ `SAFE` となった。

```
{-@ remove :: { v:Queue a | sizeQ v > 0 } -> (a, QueueN a {sizeQ v - 1}) @-}
remove :: Queue a -> (a, Queue a)
remove (Q (SL n (x:xs)) b) = (x, makeq (SL (n-1) xs) b)
```

どうやら、分解の場合も思っている感じに動いている。


なので、この問題の答えとしてはやはり遅延評価で部分式を共有した形式にしておかないと `Okasaki's Lazy Queue` としての性質を満たさないという感じだと思うが、詳しくはそっちを確認する必要がありそうだ。

それか `SL` を使った時点で `size` がわかっているので、そこからわかるのかもしれない・・・。
もう少し単純な例で確認する必要がありそう。