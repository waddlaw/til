# Polymorphism

## Exercise 4.1 (Vector Head)

### 問題

`head''` の `undefined` を入力の `vec` が空でない時のみ値を返すような実装に置き換えよ。

```haskell
head'' :: Vector a -> Maybe a
head'' vec = undefined
```

上記のコードを `LiquidHaskell` にかけると `SAFE` となる。

### 解答

```haskell
import Prelude hiding (head, null)
import Data.Vector

{-@ head' :: Vector a -> Maybe a @-}
head'' :: Vector a -> Maybe a
head'' vec
  | null vec  = Nothing
  | otherwise = Just $ head vec
```

## Exercise 4.2 (Unsafe Lookup)

`unsafeLookup` 関数は `(!)` 演算子の引数を反転させた関数である。

以下の実装が `LiquidHaskell` で受理されるように `unsafeLookup` 関数の仕様を変更せよ。

```haskell
{-@ unsafeLookup :: Int -> Vector a -> a @-}
unsafeLookup index vec = vec ! index
```

### エラーメッセージの内容

```shell
Error: Liquid Type Mismatch

 7 | unsafeLookup index vec = vec ! index
                              ^^^^^^^^^^^

   Inferred type
     VV : {v : Int | v == index}

   not a subtype of Required type
     VV : {VV : Int | VV >= 0
                      && VV < vlen vec}

   In Context
     vec : {vec : (Vector a) | 0 <= vlen vec}

     index : Int
```

### 解答

```haskell
import Data.Vector

-- Exercise 4.2
{-@ unsafeLookup :: x:Nat -> {v:Vector a | x < vlen v} -> a @-}
unsafeLookup :: Int -> Vector a -> a
unsafeLookup index vec = vec ! index
```

## Exercise 4.3 (Safe Lookup)

ベクターの要素にアクセスする前に境界値チェックを実行したい。

関数 `ok` を適切に実装し、`safeLookup` の実装を完成させよ。

```haskell
{-@ safeLookup :: Vector a -> Int -> Maybe a @-}
safeLookup :: Vector a -> Int -> Maybe a
safeLookup x i
    | ok        = Just (x ! i)
    | otherwise = Nothing
    where
      ok        = undefined
```

上記のコードは `SAFE` である。

### 解答

```haskell
import Prelude hiding (length)
import Data.Vector

{-@ safeLookup :: Vector a -> Int -> Maybe a @-}
safeLookup :: Vector a -> Int -> Maybe a
safeLookup x i
    | ok        = Just (x ! i)
    | otherwise = Nothing
    where
      ok        = 0 <= i && i < length x
```

## Exercise 4.4 (Guards)

以下の `vectorSum` の実装で `i < sz` を `i <= sz` にすると何が起きるか？

```haskell
import Prelude hiding (length)
import Data.Vector

{-@ vectorSum :: {v:Vector Int | 0 <= vlen v} -> Int @-}
vectorSum ::  Vector Int -> Int
vectorSum vec = go 0 0
  where
    {-@ lazy go @-}
    {-@ go :: Int -> i:{n:Nat | n <= vlen vec} -> Int @-}
    go acc i
      | i < sz = go (acc + (vec ! i)) (i + 1)
      | otherwise = acc
    sz = length vec
```

### 解答

`i <= sz` に変更すると `vec` の長さを超えて要素を参照するので以下のように実行時エラーが発生する。

```shell
*Main> vectorSum (fromList [1, -2, 3])
*** Exception: ./Data/Vector/Generic.hs:245 ((!)): index out of bounds (3,3)
CallStack (from HasCallStack):
  error, called at ./Data/Vector/Internal/Check.hs:87:5 in vector-0.12.0.1-CnPH69pDwM4A5esizlXfXi:Data.Vector.Internal.Check
```

### 補足

`vectorSum` の内部関数 `go` に `lazy` キーワードを指定しない場合は以下のエラーが発生する。

```shell
Error: Liquid Type Mismatch

11 |       | i < sz = go (acc + (vec ! i)) (i + 1)
                           ^^^^^^^^^^^^^^^

   Inferred type
     VV : {v : Int | v == acc + ?b
                     && v == ?a}

   not a subtype of Required type
     VV : {VV : Int | VV < acc
                      && VV >= 0}

   In Context
     ?b : Int

     ?a : {?a : Int | ?a == acc + ?b}

     acc : Int
```

これは停止性の判定を `go` の第一引数で行なっているが、値が増加しているため、このようなエラーになったと思われる。

`Int` ではなく `Num a` にすると、以下のように、また違うエラーメッセージが表示される。

```sell
Error: Liquid Type Mismatch

 23 |       | i < sz = go (acc + (vec ! i)) (i + 1)
                                             ^^^^^

   Inferred type
     VV : {v : Int | v == i + ?a
                     && v == ?b}

   not a subtype of Required type
     VV : {VV : Int | VV >= 0
                      && VV <= vlen vec
                      && VV < i}

   In Context
     ?b : {?b : Int | ?b == i + ?a}

     vec : {vec : (Vector a) | 0 <= vlen vec}

     ?a : {?a : Int | ?a == (1 : int)}

     i : {i : Int | i >= 0
                    && i <= vlen vec}
```
